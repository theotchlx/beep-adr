= II. Managing the authentication system with OIDC

The following sections concern my proposal to integrate Open ID Connect authentication to Beep.

== 1. Authentication requirements

In this section, we will discuss the functionnalities and requirements we need from Beep's authentication mechanism, as well as possible constraints.

=== Authentication requirements

Beeps needs to provide the following authentication mechanisms:

- User can connect to Beep via their Polytech account.
- User can connect to Beep via their Google account.
- User can associate their Google and Beep accounts.
- Single-sign on (SSO), allowing users to connect via their Polytech account or Google account.

To provide these authentication services, Beep needs to integrate the Open ID Connect (OIDC) protocol, which standardizes authentication, identification and authorization processes between systems that provide authentication.
Polytech uses the Lightweight Directory Access Protocol (LDAP), which is why we can't associate a Beep account to a Polytech account????
First of all, the authentication system will be managed by Keycloak, an identity and access management platform

---
OIDC will be Keycloak
A user can log in with his Polytech account (=> Polytech LDAP access via OIDC - to be taken into account in your deployment scheme)
A user can associate his user account with a Google account

Needs:
link Google auth, Polytech auth, Beep auth (and associate accounts), manage identification and authentication and them give way to authorization. And take into account the fact that, iirc, keycloak can do all three. (verify)

=== Authentication constraints

Should Beep store user data, have access to user data? RGPD? Deleting an account and all associated data, as well as from backups?

Constraints/limits:
- User data privacy:
- User data security:
- User data integrity:
- User data availability:

== 2. OpenID Connect, OAuth2 and Beep

Very briefly present the What? and Why? of these protocols, as an introduction to the next section: How?

== 3. Comparing available technologies

Brief section +
List of tech stacks for OIDC and identification+authentication system, with comparisons, benefits, drawbacks; if possible benchmarks (as pocs).

No benchmarks (as pocs) because no time + keycloak constraint makes dis double-dumdum.

== 4. Authentication system design and implementation with Keycloak

In this section, we will go over how OIDC can be integrated into Beep's microservices architecture as an authentication system.

Proposition (explanation of the approach, system design, how it fits into chapter I's component and diagrams), and sequence/activity diagram(s). +
The PoC too.

== 4. Keycloak as an OIDC provider

In this section, we will go over Keycloak, the technology chosen to manage authentication in Beep.

[Keycloak](https://www.keycloak.org/) is an [open source](https://github.com/keycloak/keycloak) identity and access management server/service.

Keycloak provides the following features:

- (External ?) authentication manager thingy OIDC provider
- Identity Brokering and Social Login (setup through admin console, no code needed)
- User Federation: built-in support to connect to existing LDAP or Active Directory servers.
- Single-Sign On (SSO) which we need for apofenzioxnw
- OIDC provider
- RBAC (role based) authz AND "fine grained": If role based authorization doesn't cover your needs, Keycloak provides fine-grained authorization services as well. This allows you to manage permissions for all your services from the Keycloak admin console and gives you the power to define exactly the policies you need.

- Add authentication to applications and secure services with minimum effort.
- No need to deal with storing users or authenticating users.
- Keycloak provides user federation, strong authentication, user management, fine-grained authorization, and more. 

POC: `docker run --name keycloak -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak start-dev`
on proxmox VM
Create a custom second (not the default) realm. The default should be used only for managing the keycloak server. Our custom realm will be for authentication and authorization purposes.
https://www.youtube.com/watch?v=fvxQ8bW0vO8

The UI and backend are gonna be keycloak "clients" (create in keycloak admin UI)
Public vs private client : public client cannot securely store a client's secret.
Web UI is public client, private/confidential client is for server-to-server communication.

Tokens in OIDC flow: https://www.csharp.com/article/accesstoken-vs-id-token-vs-refresh-token-what-whywhen/
Access, refresh, ID tokens. Their individual scopes.

> Keycloak: once the user has authenticated via Keycloak, it provides tokens for the user, including ID, Access and Refresh tokens, which are JWTs. These are not shared with the frontend, but are stored on the gateway and associated with the user’s session.

As for token contents, only ID so that data is not shared with clients/transmitted/stored there, and as such, always fresh.

OAuth is authz. OIDC is an authn, identity super-layer. I believe.

> With microservice architectures, one of the most used authentication type is OIDC (OpenID Connect), which adds authentication functionality to the OAuth2 protocol used for the authorization part with JWT Token. An open source popular identity provider used for this purpose is Keycloak. Other commercial OIDC alternatives include Okta, AUth0, Microsoft Azure Active Directory (AD), AWS Cognito and so on.

== 5. Microservices architecture re-design considering Keycloak integration

In this section
Let us update our architecture diagram from part one to include Keycloak as an authentication service.

keycloak, api-gateway, services hidden behind in DMZ...

Keycloak replacing the user service? Or being its database? (what about preferences, etc?) -> What can it store, what can it do.


API Gateway Considerations:

- The API Gateway can handle request authentication by verifying JWT tokens issued by Keycloak.
- It can also route requests to the appropriate microservices based on the user's identity and permissions.

Possible Architecture:

- Keycloak → Handles authentication (login, token issuance, session management).
- API Gateway → Enforces authentication & authorization before routing requests.
- User Service → Manages user-related data beyond authentication.
- Other Microservices (Chat, Call, Search, etc.) → Consume user identity from JWT.

About what Keycloak can store, it's authentication-related information (username, password, email; roles, groups; authentication settings such as MFA, login attemps, sessions; OIDC tokens, SSO and stuff)
So the User service would still need a database to store user preferences, settings, in-apps stats or whatever, ... -> Decouple authentication logic from application logic. And more stuff.

=== Why an api gateway/why network zones/network zones separation

Why we need an api-gateway: (microservices architecture complex, poses pbs, api gateway fixes these)
https://www.solo.io/topics/api-gateway/api-gateway-microservices

Manages request endpoints so that endpoint updates to services are internal only and not exposed to users? And stuff. See all that.
Also is the only service that talks to keycloak, as an OAuth2 Client.
User is a public client, api-gateway is a confidential client, maybe? The tokens it gets are used when communicating with a backend service.
> API Gateway acts as an OAuth2 Client: in this case, any unauthenticated incoming request will initiate a flow to obtain a valid Token. Once the token is acquired by the gateway, it is then used when sending requests to a backend service. The API Gateway interacts with the authorization server to obtain access and refresh tokens and stores them securely.

Maybe the other services do communicate to keycloak, but differently than the api-gateway?
So that the api gateway doesn't have a huge load to handle?

> At microservice level, authentication is not intended as the authentication used for identify users of an application. Authentication for a microservice means receive request authenticated and in this example means that all calls received from the gateway must be authenticated. A common example of authentication on microservices is JWT tokens. Endpoints exposed by microservices will only be accessible if a valid JWT token is provided.

disadvantage: keycloak/authentication server is our SPOF. If not the api-gateway.

2-3 zones?
One (or two?) have to be publicly accessible: api-gateway (and keycloak?) or just keycloak? nah. Api-gateway is the endpoints, right?

Maybe use keycloak only for user management identity and authentication, and for authz use something else, and mTLS for inter-services communication security/authentication? To avoid having too much load on keycloak/SPOF? Or does that just lead to more SPOFs? Would that be better/more scalable anyways? And performance? (What are Beep's performance/speed requirements? In/from chapter 0.)

RBAC on user, then OPA/Permify/... for ABAC/PBAC/ReBAC/...? Or all authz via keycloak? Lelz. ? ??
> access tokens are also used by the underlying services for the role-based user authorization part. Roles are defined on Keycloak, assigned to users and included in the access tokens.

// Info : permify is bad for fetching data. It just wants to answer Y/N. Not a list of ID...
// Et c'est un peu comme un elastic search en fait. Genre il va pas requêter la donnée tout seul, tu lui donnes (avec un svc devant) et lui va bosser dessus (te renvoyer oui/non t'es autorisé ou pas)

=== How Keyclaok handles identification+authentication+authorization

Explanations, diagrams, etc.

=== Connecting Keycloak with surrounding authentication mechanisms

PoC with current Beep app. Google + Polytech LDAP auth into an SSO or smth.

====
**WIP and sources**

For the poc, use react-oidc-context

Goatesque : https://medium.com/@a.zagarella/microservices-architecture-a-real-business-world-scenario-c77c31a957fb

Montrer les tokens reçus à la connection/création de compte, SSO, etc.

https://adil.medium.com/multi-container-patterns-in-kubernetes-adapter-ambassador-sidecar-40bddbe7c468
K8s containers-in-pod patterns identified : sidecar, adapter, ambassador. (more?)

list of technologies & concepts that can be used:

- OAuth2
- OpenID Connect
- SAML
- Ory
- Okta L.O.L.
- Keycloak ofc
- SSO
- See how GCP (and others) do IAM.
- more?

Lier les méthodes d'authentification aux comptes

https://developers.google.com/identity/protocols/oauth2

Oauth2: https://www.youtube.com/watch?v=ZV5yTm4pT8g
OIDC (surcouche ?): https://www.youtube.com/watch?v=t18YB3xDfXI

à GCP, pour la comm entre CHAQUE service, y'a un système d'AUTHENT puis d'authorization !!! Pas juste authorization (0 trust approach). Est-ce que ça suffit d'avoir du chiffrement entre les services, ou faut-il un système d'auth complet ?

Faut des trucs en plus pour les microservices :
Circuit breaking pattern. Important pour les microservices pour pas que ça call en continue avec les retry réseau. Retry exponentiel (1s, 10s, 1mn... et que ça bloque tout le service) -> on arrête d'appeler le service (on ouvre le circuit) et pas mécanisme de fallback (réponse préfaite en cas de pb, genre "ah dsl jpp afficher ça en fait" alors que ça chargeait) -> En gros gestion d'erreur réseau en fait. Pour éviter surcharge réseau + jamais de réponse.
Aussi circuit breaking, fault tolerance, latency... Problématiques de microservices entre eux.
-> Quota (peut faire 1M d'appels à service X sur un mois, etc) + Rate limiting (même chose mais sur une période très courte, genre secondes ou 1mn).

Et logging, metrics (métriques techniques, CPU, etc. Ou plus fonctionnelles rédigées par le développeur genre nb de requêtes, etc.), distributed tracings (suivre l'appel de son entrée et toutes ses transitations de svc en svc. Permet d'identifier dans quel svc y'a des pbs quand y'a un pb sur la requete, genre latence ou erreurs) et topology.

Security, observability, network resilience (genre trucs de circuit breaking etc), policies. En sidecar containers (envoy??) en PLUS du service logique !! dans le pod. Donc un container app et un container proxy qui a les 4 trucs secu, obs, netw resi et poli. Qui intercepte en premier tous les calls puis retransmet.

Inscrire les services et leurs endpoints dans une bibliothèque de services, un "service discovery". Pour gérer leur scalabilité et des trucs.

Dans un service mesh : Il y a un control plane : api/interface pour donner des instructions pour configurer le control plane, ses proxy qui vont appliquer les configs (d'auth, de traffic management, de sécu réseau type ntls?mtls? c'était mTLS etc. Certaines traitées en inbound ou outbound du proxy), etc;
Pour les microservices, le service mesh permet de gérer facilement le traffic entrant, sortant et intérieur aux services (traffic splitting, canary, blue-green, mirroring...), sécuriser l'accès et comms (mTLS etc.), et visibilité complète sur etc.

mTLS avec Istio ou HCP Consul

Tout ça est implémenté dans Istio !!!!

https://istio.io/latest/docs/tasks/
Exemples de comment mettre en oeuvre ces fonctionnalités !!!!!!!!!!

https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/
https://www.youtube.com/watch?v=uWmZZyaHFEY

OAUTH
OIDC
SSO
SAML

https://samarthasthan.com/posts/building-a-scalable-e-commerce-empire-a-micro-services-system-design-approach/
https://www.geeksforgeeks.org/how-discord-scaled-to-15-million-users-on-one-server/

Random important stuff:
event driven architecture and aggregates
saga pattern
service that redirects microservices
service and repository pattern
http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
https://medium.com/microsoftazure/certificate-pinning-for-mtls-authentication-at-the-istio-ingress-gateway-978ed31699ab
https://www.youtube.com/watch?v=vJweuU6Qrgo
https://www.geeksforgeeks.org/how-discord-scaled-to-15-million-users-on-one-server/
activity diagram for authentication
keycloak activity diagram
activity vs sequence diagram

https://discord.com/developers/docs/topics/oauth2
Find Discord's OAuth flow of authentication?


https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc
OAuth 2.0 is designed only for authorization, for granting access to data and features from one application to another. OpenID Connect (OIDC) is a thin layer that sits on top of OAuth 2.0 that adds login and profile information about the person who is logged in. Establishing a login session is often referred to as authentication, and information about the person logged in (i.e. the Resource Owner) is called identity. When an Authorization Server supports OIDC, it is sometimes called an identity provider, since it provides information about the Resource Owner back to the Client.
https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc#learn-more-about-oauth-and-oidc

Oauth, OIDC, identity **and access* managers: provide authentication (oauth), user identity (surcouche oidc de oauth), et parfois aussi gère l'authorization/perms! Genre okta : "and access" manager.

JWT: bien pour avoir des sessions (date d'expiration)
Ne pas mettre de data sensible
PAS DE SYSTÈME DE RÉVOCATION!! On les révoque dans le système manuellement en les supprimant... C pas dans la spec. (biscuit y a pensé, voir plus bas chap IV)
Le chiffrement du jwt dépend du SDK qui l'a créé.. Peut être passoir, si pas config, etc. Et si tu connais le SDK, tu peux crack.
-> Alternative : PASETO (Platform Agnostic Secure Token) : version specific protocols, up-to-date, secure cryptographic algorithms
Purpose explicit: public and private/local(server-side) tokens.
Plus possible de changer l'algo de chiffrement sur le haeder déchiffré du token, et signature obligatoire. Meilleures règles d'inmplémentation/fiabilité en gros.
+ système de révocation. + le fait que t'ai la partie locale sur le service = on sait/est sûr de quel service l'a créé, nativement un peu en gros.
https://permify.co/post/jwt-paseto/

Oauth : juste la clé pour la serrure
OIDC : toute l'identité raccrochée qui va avec.
====
