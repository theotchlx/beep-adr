= VI. Setting up a production ready system

FAULT TOLERANCE HEEHETEEHEEEEHEE

cia triad
principle of privilege (including in service mesh)

Migrate infrastructure to a (or 3???) proxmox cluster. With a high-availability Kube on top. Separate etcd or not? Postgres as etcd or not?
Proxmox vs apache cloudstack vs openstack.

Apache Mesos: Program against your datacenter like it’s a single pool of resources. Kubernetes pour l'infra ou qq chose comme ça.

"Mesos propose deux modèles de fédération. Une première approche place toute l'infrastructure sous une couche de contrôle et crée une abstraction des ressources du datacenter, d'un cloud public, d'un déploiement de VM par exemple. Cette couche de contrôle forme une abstraction uniforme pour l'hébergement. Avec le deuxième modèle, la technologie rassemble des déploiements Mesos distincts de manière à ce qu'aucun ne soit relié à un autre, mais coopèrent tous de manière totalement distribuée et tolérante aux pannes."

https://www.baeldung.com/apache-mesos
https://mesos.apache.org/documentation/latest/
https://agenda.infn.it/event/29701/sessions/21750/attachments/88134/117909/Apache%20Mesos.pdf

CNI plugins: Flannel, cilium, calico, ... There are more good ones!
To read to understand stuff:
https://mvallim.github.io/kubernetes-under-the-hood/documentation/kube-flannel.html
https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/
https://kubernetes.io/docs/concepts/cluster-administration/networking/
Flannel has basic features when compared to cilium/calico. Supposedly. I haven't tested it yet.

MinIO vs seaweedfs vs deuxfleurs's garage

Pour le load balancer à self hoster :
https://geek-cookbook.funkypenguin.co.nz/kubernetes/loadbalancer/
https://medium.com/@ferdinandklr/creating-a-production-ready-self-hosted-kubernetes-cluster-from-scratch-on-a-vps-ipv6-compatible-660aa5018feb
MetalLB(?)

"Target diagram" == "Diagramme de l'architecture cible" !!

How? to put this in place

Like google: Dev measured in agility, ops measured in stability of product? No, makes quarrels (cuz change breaks stability) -> SRE approach = budget d'availability (25.9s à 99.999% par exemple). Availability : client's metrics ! Product/service/site must be ...(use cases/scenarios/critical user journey) (available, fast, provide good stuff, etc.). -> dev push push push... Until unavailability time is épuisé -> mains levées du clavier et ops et dev se concentrent sur availability.

Service mesh: Istio, Linkerd
Mutual TLS (mTLS) encryption for secure inter-service communication

Each team works on its service's logic. And a networks team + ... team works on the sidecar proxies (fault tolerance/circuit breakers: link my poc; auth; etc...)

cockroachdb

Mettre des UUIDs v4 ou v7 en bdd plutôt que incrémentaux, pour éviter que les attaquants puissent juste incrémenter l'ID pour trouver les autres users et voler toutes les infos des users ds la bdd.
Aussi UUID v4 a plus de chances de clasher quand on en génère beaucoup d'un coup. UUIDv7 ajoute un timestamp. Donc en plus d'être plus unique, ça peut être trié, optimiser l'indexation, etc.
https://www.uuidgenerator.net/
Les UUIDv4 étaient trop rapides à faire : plus faciles à bruteforce. Les UUIDv7 sont un peu plus longs à générer... Mais exprès. Pour que ça soit plus dur à brute force.
Genre ont rajouté des calculs de courbes elliptiques exprès pour que ça soit plus complexe en calcul et hasard, et que ça prenne plus de temps.

TLS : va que dans un sens client-serveur. Le client sait qui est le serveur mais le serveur sait pas.

QUIC (Quick UDP Internet Connections) : TLS + UDP. Gagne du temps/vitesse sur les handshakes TCP (et/ou TLS?). Et gestion de stream.
Streaming dans la spec de TCP est rarement/efficiement bien implémenté.
Rapidifie de bcp le first content load dûes aux handshakes TLS?

mTLS : davantage confiance au client. Mutual authentication: improve trust.

TLS : le serveur est vérifé et le client peut lui faire confiance.
mTLS : le serveur peut aussi faire confiance au client! Peut plus sniffer.
Il faut aussi des règles de sécurité. Pour complètement éviter le MITM.

RGPDR : quand user demande à ce que ses data soit del, cela inclue aussi les backups de bd !
Taille max de data chiffrable par clé = dépend de la taille de la clé. C'est aussi une des raisons pour laquelle on utilise des clés symmétriques.

Toutes les données utilisateurs sont chiffrées : email, nom, mdp.

Tradeoff qualité chiffrement et temps de création du secret. Par contre plus de temps = beaucoup plus dur de déchiffrer pour l'attaquant.

Bcrypt: itère sur un nb de tour. Utilise du sel (aléatoire)
GPUs pour paralléliser calculs : se prévenir d'attaques de crackage psswd par GPU : Argon2. Restreint l'usage mémoire. Optimisé pour la résistance contre les GPUs. => cryptomonnaies, applis avec moins de risques de side channel attacks.
Plus lent que bcrypt tho. Donc pour un usecase anti-GPU.

Les clés qui chiffrent les data en bdd... Sont aussi en bdd. Si je supprime la clé on peut faire un système qui clean les data user dans toutes les bdd. Avec les saga pattern.
Mais les clés sont dans une autre bd du coup? Ou dans la bd de chaque service, clés diffs chiffrent données diffs?

Ou les clés sont côté client. D'autres PBs (perdre sa clé, voler, ...) Mais plus de confidentialité.

Ou split la clé privée en morceaux, et il les faut tous !! (Horcrux) https://github.com/jesseduffield/horcrux
Vault fait ça ?

